
import { Claim, ClaimLiabilityType, Policy } from '../types';
import { supabase } from './supabase';
import { DB } from './db';

// --- LIABILITY LOGIC (Pure Function) ---
// This determines if a claim is strictly Active or just Informational
export const determineLiability = (
    policy: Policy,
    lossDate: string,
    reportDate: string,
    coverageBasis: 'occurrence' | 'claims_made' = 'occurrence',
    retroactiveDate?: string
): { type: ClaimLiabilityType; reason: string } => {

    const inception = new Date(policy.inceptionDate).getTime();
    const expiry = new Date(policy.expiryDate).getTime();
    const loss = new Date(lossDate).getTime();
    const report = new Date(reportDate).getTime();

    // 1. Basic Validity
    if (isNaN(loss)) return { type: 'INFORMATIONAL', reason: 'Invalid Loss Date' };

    // 2. Occurrence Basis Logic
    if (coverageBasis === 'occurrence') {
        if (loss >= inception && loss <= expiry) {
            return { type: 'ACTIVE', reason: 'Loss occurred within policy period' };
        }
        return { type: 'INFORMATIONAL', reason: `Loss date outside period (${policy.inceptionDate} to ${policy.expiryDate})` };
    }

    // 3. Claims Made Logic
    if (coverageBasis === 'claims_made') {
        // Must be REPORTED during policy period
        if (report < inception || report > expiry) {
            return { type: 'INFORMATIONAL', reason: 'Reported outside policy period' };
        }
        
        // Loss must be after Retroactive Date (if exists)
        if (retroactiveDate) {
            const retro = new Date(retroactiveDate).getTime();
            if (loss < retro) {
                return { type: 'INFORMATIONAL', reason: 'Loss occurred before retroactive date' };
            }
        }
        
        return { type: 'ACTIVE', reason: 'Claims-made criteria met' };
    }

    return { type: 'INFORMATIONAL', reason: 'Default fallback' };
};

// --- DATA ACCESS ---

export const ClaimsService = {
    getClaimsForPolicy: async (policyId: string): Promise<Claim[]> => {
        if (!supabase) return [];
        const { data, error } = await supabase
            .from('claims')
            .select(`
                *,
                transactions:claim_transactions(*)
            `)
            .eq('policy_id', policyId)
            .order('report_date', { ascending: false });
        
        if (error) {
            console.error("Error fetching claims", error);
            return [];
        }

        // Map DB casing to camelCase
        return data.map((row: any) => ({
            id: row.id,
            policyId: row.policy_id,
            claimNumber: row.claim_number,
            liabilityType: row.liability_type,
            status: row.status,
            lossDate: row.loss_date,
            reportDate: row.report_date,
            description: row.description,
            claimantName: row.claimant_name,
            locationCountry: row.location_country,
            importedTotalIncurred: row.imported_total_incurred,
            importedTotalPaid: row.imported_total_paid,
            transactions: row.transactions?.map((t: any) => ({
                id: t.id,
                transactionType: t.transaction_type,
                amount100pct: t.amount_100pct,
                amountOurShare: t.amount_our_share,
                currency: t.currency
            }))
        }));
    },

    createClaim: async (claim: Partial<Claim>): Promise<string | null> => {
        if (!supabase) {
            alert("Database connection required for Claims Module");
            return null;
        }

        // Snake_case mapping for DB
        const payload = {
            policy_id: claim.policyId,
            claim_number: claim.claimNumber,
            liability_type: claim.liabilityType,
            status: claim.status,
            loss_date: claim.lossDate,
            report_date: claim.reportDate,
            description: claim.description,
            claimant_name: claim.claimantName,
            imported_total_incurred: claim.importedTotalIncurred || 0,
            imported_total_paid: claim.importedTotalPaid || 0
        };

        const { data, error } = await supabase
            .from('claims')
            .insert(payload)
            .select('id')
            .single();

        if (error) throw error;
        return data.id;
    },

    addTransaction: async (claimId: string, type: string, amount100: number, ourSharePct: number) => {
        if (!supabase) return;
        
        const { error } = await supabase.from('claim_transactions').insert({
            claim_id: claimId,
            transaction_type: type,
            amount_100pct: amount100,
            our_share_percentage: ourSharePct
            // amount_our_share is generated by DB
        });

        if (error) throw error;
    }
};
